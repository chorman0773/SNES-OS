#ifndef __type_traits_2018_05_14_10_27
#define __type_traits_2018_05_14_10_27
#include <cstdlib>
namespace std{

  template<typename T,T val> struct integral_constant{
    constexpr static T value = val;
  };

  struct true_type :integral_constant<bool,true>{};

  struct false_type: integral_constant<bool,false>{};

  template<typename T> struct is_void:public false_type{};

  template<> struct is_void<void>:public true_type{};

  template<> struct is_void<const void>:public true_type{};

  template<> struct is_void<volatile void>:public true_type{};

  template<> struct is_void<const volatile void>:public true_type{};

  template<typename... Args> using void_t = void;

  template<typename T> struct is_nullptr:public false_type{};
  
  template<> struct is_nullptr<nullptr_t>:public true_type{};
  template<> struct is_nullptr<const nullptr_t>:public true_type{};
  template<> struct is_nullptr<volatile nullptr_t>:public true_type{};
  template<> struct is_nullptr<const volatile nullptr_t>:public true_type{};
  
  template<bool val,typename T> struct enable_if{};
  
  template<typename T> struct enable_if<true,val>{
    typedef T type;
  };
  
  template<bool val,typename T,typename U> struct conditional{
    typedef U type;
  };
  
  template<typename T,typename U> struct conditional<true,T,U>{
    typedef T type;
  };
  
  template<typename T> struct is_integral:public false_type{};
  
  template<typename T> struct is_integral<const T>:is_integral<T>{};
  
  template<typename T> struct is_integral<volatile T>:is_integral<T>{};
  
  template<typename T> struct is_integral<const volatile T>:is_integral<T>{};
  
  template<> struct is_integral<char>:public true_type{};
  
  template<> struct is_integral<short>:public true_type{};
  
  template<> struct is_integral<int>: public true_type{};
  
  template<> struct is_integral<long>:public true_type{};
  
  template<> struct is_integral<long long>:public true_type{};
  
  template<> struct is_integral<unsigned char>:public true_type{};
  
  template<> struct is_integral<unsigned short>:public true_type{};
  
  template<> struct is_integral<unsigned int>: public true_type{};
  
  template<> struct is_integral<unsigned long>:public true_type{};
  
  template<> struct is_integral<unsigned long long>:public true_type{};
  
  template<typename T> struct is_floating_point:false_type{};
  
  template<typename T> struct is_floating_point<const T>:is_floating_point<T>{};
  
  template<typename T> struct is_floating_point<volatile T>:is_floating_point<T>{};
  
  template<typename T> struct is_floating_point<const volatile T>:is_floating_point<T>{};
  
  template<> struct is_floating_point<float>:true_type{};
  
  template<> struct is_floating_point<double>:true_type{};
  
  template<> struct is_floating_point<long double>:true_type{};
  
  template<typename T> struct is_array:false_type{};
  
  template<typename T> struct is_array<const T>:is_array<T>{};
  
  template<typename T> struct is_array<volatile T>:is_array<T>{};
  
  template<typename T> struct is_array<const volatile T>:is_array<T>{};
  
  template<typename T> struct is_array<T[]>:true_type{};
  
  template<typename T,size_t N> struct is_array<T[N]>:true_type{};
  
  //Uses compiler level overloads
  template<typename T> struct underlying_type{};
  
  template<typename T> struct is_enum:false_type{};
  
  //SFINAE Implementation of is_enum
  template<typename T> struct is_enum<typename enable_if<is_same<void_t<underlying_type<T>>,void_t<>>::value,T>::type>:true_type{};
  
  //Uses compiler level overloads
  template<typename T> struct is_class:false_type{};
  
  //Uses compiler level overloads
  template<typename T> struct is_union:false_type{};
  
  template<typename T> struct is_function:false_type{};
  
  template<typename T,typename... Args> struct is_function<T(Args...)>:true_type{};
  
  template<typename T> struct is_pointer:false_type{};
  
  template<typename T> struct is_pointer<T*>:true_type{};
  
  template<typename T> struct is_pointer<T* const>:true_type{};
  
  template<typename T> struct is_pointer<T* volatile>:true_type{};
  
  template<typename T> struct is_pointer<T* const volatile>:true_type{};
  
  template<typename T> struct is_lvalue_reference:false_type{};
  
  template<typename T> struct is_lvalue_reference<T&>:true_type{};
  
  template<typename T> struct is_rvalue_reference:false_type{};
  
  template<typename T> struct is_rvalue_reference<T&&>:true_type{};
  
  template<typename T> struct is_member_object_pointer:false_type{};
  
  template<typename T,class B> struct is_member_object_pointer<T B::*>:true_type{};
  
  template<typename T,class B> struct is_member_object_pointer<T B::* const>:true_type{};
  template<typename T,class B> struct is_member_object_pointer<T B::* volatile>:true_type{};
  template<typename T,class B> struct is_member_object_pointer<T B::* const volatile>:true_type{};
  
  template<typename T> struct is_member_function_pointer:false_type{};
  
  template<typename T,class B,typename... Args> struct is_member_function_pointer<T (B::*)(Args...)>:true_type{};
  
  template<typename T> struct is_fundemental:false_type{};
  
  template<typename T> struct is_fundemental<typename enable_if<is_void<T>::value||is_nullptr<T>::value||is_integral<T>::value||is_floating_point<T>::value,T>::type>: true_type{};
  
  template<typename T> struct is_arithmetic:false_type{};
  
  template<typename T> struct is_arithemtic<typename enable_if<is_integral<T>::value||is_floating_point<T>::value>::type>:true_type{};
  
  template<typename T> struct is_scalar:false_type{};
  
  template<typename T> struct is_scalar<typename enable_if<is_arithmetic<T>::value||is_pointer<T>::value||
      is_member_object_pointer<T>::value||is_member_function_pointer<T>::value||is_nullptr<T>:value
      ||is_enum<T>::value,T>::type>:true_type{};
      
 
  
  
  
};
#endif
