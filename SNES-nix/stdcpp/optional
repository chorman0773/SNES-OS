#ifndef __optional_2018_05_23_16_50
#define __optional_2018_05_23_16_50
#include <type_traits>
#include <utility>
namespace std{
  struct nullopt_t{};

  inline constexpr nullopt_t nullopt{};

  typedef<typename T> class optional{
  private:
    alignas(alignof(T)) union{ 
      unsigned char mem[sizeof(T)];
      T val;
    }data;
    bool hasValue = false;
  public:
    optional(nullopt_t) noexcept{}
    optional()noexcept =default;
    optional(const optional<T>& c){
      if(c.hasValue){
        hasValue = true;
        data = {.val=c.getValue()};
      }
    }
    optional(optional<T>&& o){
      if(o.hasValue){
        hasValue = true;
        data = {.val=std::move(o.getValue()};
        o.hasValue = false;
      }
    }
    explicit template<typename U> optional(const optional<typename std::conditional<false,decltype(T(declval<U>())),U>::type>& c){
      if(c.hasValue){
        hasValue = true;
        data = {.val=c.getValue()};
      }
    }
    explicit template<typename U> optional(optional<typename std::conditional<false,decltype(T(declval<U>())),U>::type>&& o){
     if(o.hasValue){
        hasValue = true;
        data = {.val=std::move(o.getValue()};
        o.hasValue = false;
      }
    }
    template<typename... Args> optional(typename std::conditional<false,decltype(T(declval<Args>...())),in_place_t>::type t,Args&&... args){
      data = {.val=T(std::forward<Args>(args)...)};
    }
  };

};

#endif
