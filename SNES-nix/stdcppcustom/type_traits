#include <type_traits>

namespace std{
  namespace custom{
    using true_type = std::true_type;
    using false_type = std::false_type;
    using echo_type = std::echo_type;
    using integral_constant = std::integral_constant;
    template<typename T> struct has_decay_type:
      std::boolean_constant<!std::is_same<t,typename std::decay<T>::type>::value>{};
    template<typename T> struct is_iterable:false_type{};
    template<typename T,std::size_t Size> struct is_iterable<T[Size]>:true_type{};
    template<typename T,std::size_t Size> struct is_iterable<T(&)[Size]>:true_type{};
    template<class T> struct is_iterable<typename std::conditional<false,
        typename std::conditional<false,decltype(declval<T>().begin()),decltype(declval<T>().end())>::type,T>::type>:true_type{};
    template<typename T> struct has_attachment : false_type{};
    template<typename T> struct has_attachment<void*>:false_type{};
    template<typename T> struct has_attachment<const void*>:true_type{};
    template<typename T> struct has_attachment<volatile void*>:true_type{};
    template<typename T> struct has_attachment<const volatile void*>:true_type{};
    template<typename T> struct has_attachment<const T>:true_type{};
    template<typename T> struct has_attachment<volatile T>:true_type{};
    template<typename T> struct has_attachment<const volatile T>:true_type{};
    template<typename T> struct has_attachment<T&&>:true_type{};
    template<typename T> struct has_attachment<T&>:true_type{};
    template<typename T> struct has_attachment<T*>:true_type{};
    template<typename T> struct has_attachment<T[]>:true_type{};
    template<typename T,std::size_t N> struct has_attachment<T[N]>:true_type{};
    
    template<typename T> struct remove_attachments : echo_type<T>{};
    template<> struct remove_attachments<void*> : echo_type<void*>{};
    template<> struct remove_attachments<const void*>:echo_type<void*>{};
    template<> struct remove_attachments<volatile void*>:echo_type<void*>{};
    template<> struct remove_attachments<const volatile void*>:echo_type<void*>{};
    template<typename T> struct remove_attachments<const T>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<volatile T>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<const volatile T>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<T*>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<T&>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<T&&>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<T[]>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T,std::size_t N> struct remove_attachmenst<T[N]>:echo_type<typename remove_attachments<T>::type>{};
    
    template<typename T,typename U> struct get_type_offset;
    
    template<typename T> struct get_type_offset<T,T> : integral_constant<std::ptrdiff_t,0>{};
    
    template<typename T,typename U> struct get_type_offset<typename std::enable_if<!std::is_base<T,U>::value,T>::type,U>:integral_constant<std::ptrdiff_t,-1>{};
    //Compiler Assisted Overloads used
    
    namespace operators{
      template<typename T,typename U=T> struct has_eq:false_type{};
      template<typename T,typename U> struct has_eq<typename std::conditional<false,decltype(declval<const T>()==declval<const U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_ne:false_type{};
      template<typename T,typename U=T> struct has_ne<typename std::conditional<false,decltype(declval<const T>()!=declval<const U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_lt:false_type{};
      template<typename T,typename U=T> struct has_lt<typename std::conditional<false,decltype(declval<const T>()<declval<const U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_le:false_type{};
      template<typename T,typename U=T> struct has_le<typename std::conditional<false,decltype(declval<const T>()<=declval<const U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_ge:false_type{};
      template<typename T,typename U=T> struct has_ge<typename std::conditional<false,decltype(declval<const T>()>=declval<const U>()),T>::type,U>:true_type{};
     
      template<typename T,typename U=T> struct has_gt:false_type{};
      template<typename T,typename U=T> struct has_gt<typename std::conditional<false,decltype(declval<const T>()>declval<const U>()),T>::type,U>:true_type{};      
      
      template<typename T,typename U=T> struct has_multicompare:false_type{};
      template<typename T,typename U=T> struct has_multicompare<typename std::conditional<false,decltype(declval<const T>()<=>declval<const U>()),T>::type,U>:true_type{};
    };
    template<typename T,typename U> struct is_comparable_with:false_type{};
    template<typename T,typename U> struct is_comparable_with<typename std::enable_if<operators::has_multicompare<T,U>::value,T>::type,U>:true_type{};
    template<typename T,typename U> struct is_comparable_with<typename std::enable_if<
      std::conjunction<operators::has_eq<T,U>,operators::has_ne<T,U>,operators::has_lt<T,U>,operators::has_le<T,U>,
        operators::has_ge<T,U>,operators::has_gt<T,U>>::value,T>::type,U>:true_type{};
        
    template<typename T> using is_comparable = is_comparable_with<T,T>;
    
    template<typename T,typename U> struct is_mutually_comparable:false_type{};
    template<typename T> struct is_mutually_comparable<typename std::enable_if<is_comparable<T>::value,T>::type,T>:true_type{};
    template<typename T,typename U> struct is_mutually_comparable<typename std::enable_if<is_comparable_with<T,U>::value,T>::type,
      typename std::enable_if<is_comparable_with<U,T>::value,U>::type>:true_type{};
    
  };

};
