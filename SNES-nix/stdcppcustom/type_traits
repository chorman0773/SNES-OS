#include <type_traits>

namespace std{
  namespace custom{
    using true_type = std::true_type;
    using false_type = std::false_type;
    using echo_type = std::echo_type;
    using integral_constant = std::integral_constant;
    template<typename T> struct has_decay_type:
      std::boolean_constant<!std::is_same<t,typename std::decay<T>::type>::value>{};
    template<typename T> struct is_iterable:false_type{};
    template<typename T,std::size_t Size> struct is_iterable<T[Size]>:true_type{};
    template<typename T,std::size_t Size> struct is_iterable<T(&)[Size]>:true_type{};
    template<class T> struct is_iterable<typename std::conditional<false,
        typename std::conditional<false,decltype(declval<T>().begin()),decltype(declval<T>().end())>::type,T>::type>:true_type{};
    template<typename T> struct has_attachment : false_type{};
    template<typename T> struct has_attachment<void*>:false_type{};
    template<typename T> struct has_attachment<const void*>:true_type{};
    template<typename T> struct has_attachment<volatile void*>:true_type{};
    template<typename T> struct has_attachment<const volatile void*>:true_type{};
    template<typename T> struct has_attachment<const T>:true_type{};
    template<typename T> struct has_attachment<volatile T>:true_type{};
    template<typename T> struct has_attachment<const volatile T>:true_type{};
    template<typename T> struct has_attachment<T&&>:true_type{};
    template<typename T> struct has_attachment<T&>:true_type{};
    template<typename T> struct has_attachment<T*>:true_type{};
    template<typename T> struct has_attachment<T[]>:true_type{};
    template<typename T,std::size_t N> struct has_attachment<T[N]>:true_type{};
    
    template<typename T> struct remove_attachments : echo_type<T>{};
    template<> struct remove_attachments<void*> : echo_type<void*>{};
    template<> struct remove_attachments<const void*>:echo_type<void*>{};
    template<> struct remove_attachments<volatile void*>:echo_type<void*>{};
    template<> struct remove_attachments<const volatile void*>:echo_type<void*>{};
    template<typename T> struct remove_attachments<const T>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<volatile T>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<const volatile T>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<T*>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<T&>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<T&&>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T> struct remove_attachments<T[]>:echo_type<typename remove_attachments<T>::type>{};
    template<typename T,std::size_t N> struct remove_attachmenst<T[N]>:echo_type<typename remove_attachments<T>::type>{};
    
    template<typename T,typename U> struct get_type_offset;
    
    template<typename T> struct get_type_offset<T,T> : integral_constant<std::ptrdiff_t,0>{};
    
    template<typename T,typename U> struct get_type_offset<typename std::enable_if<!std::is_base<T,U>::value,T>::type,U>:integral_constant<std::ptrdiff_t,-1>{};
    //Compiler Assisted Overloads used
    
    namespace operators{
      template<typename T,typename U=T> struct has_eq:false_type{};
      template<typename T,typename U> struct has_eq<typename std::conditional<false,decltype(declval<const T>()==declval<const U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_ne:false_type{};
      template<typename T,typename U=T> struct has_ne<typename std::conditional<false,decltype(declval<const T>()!=declval<const U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_lt:false_type{};
      template<typename T,typename U=T> struct has_lt<typename std::conditional<false,decltype(declval<const T>()<declval<const U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_le:false_type{};
      template<typename T,typename U=T> struct has_le<typename std::conditional<false,decltype(declval<const T>()<=declval<const U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_ge:false_type{};
      template<typename T,typename U=T> struct has_ge<typename std::conditional<false,decltype(declval<const T>()>=declval<const U>()),T>::type,U>:true_type{};
     
      template<typename T,typename U=T> struct has_gt:false_type{};
      template<typename T,typename U=T> struct has_gt<typename std::conditional<false,decltype(declval<const T>()>declval<const U>()),T>::type,U>:true_type{};      
      
      template<typename T,typename U=T> struct has_multicompare:false_type{};
      template<typename T,typename U=T> struct has_multicompare<typename std::conditional<false,decltype(declval<const T>()<=>declval<const U>()),T>::type,U>:true_type{};
    
      template<typename T,typename U=T> struct has_add:false_type{};
      template<typename T,typename U> struct has_add<typename std::conditional<false,decltype(declval<T>()+declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_sub:false_type{};
      template<typename T,typename U> struct has_sub<typename std::conditional<false,decltype(declval<T>()-declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_mul:false_type{};
      template<typename T,typename U> struct has_mul<typename std::conditional<false,decltype(declval<T>()*declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_div:false_type{};
      template<typename T,typename U> struct has_div<typename std::conditional<false,decltype(declval<T>()/declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_mod:false_type{};
      template<typename T,typename U> struct has_mod<typename std::conditional<false,decltype(declval<T>()%declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_and:false_type{};
      template<typename T,typename U> struct has_and<typename std::conditional<false,decltype(declval<T>()&declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_or:false_type{};
      template<typename T,typename U> struct has_or<typename std::conditional<false,decltype(declval<T>()|declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_xor:false_type{};
      template<typename T,typename U> struct has_xor<typename std::conditional<false,decltype(declval<T>()^declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_rshift:false_type{};
      template<typename T,typename U> struct has_rshift<typename std::conditional<false,decltype(declval<T>()>>declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_lshift:false_type{};
      template<typename T,typename U> struct has_lshift<typename std:conditional<false,decltype(declval<T>()<<declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U> struct has_assign:false_type{};
      template<typename T,typename U> struct has_assign<typename std::conditional<false,decltype(declval<T&>()=declval<U>(),T>::type,U>:false_type{};
      
      template<typename T> using has_copy_assign = has_assign<T,const T&>;
      template<typename T> using has_move_assign = has_assign<T,T&&>;
      
      template<typename T> struct has_preinc:false_type{};
      template<typename T> struct has_preinc<typename std::conditional<false,decltype(++declval<T&>()),T>::type>:true_type{};
      
      template<typename T> struct has_postinc:false_type{};
      template<typename T> struct has_postinc<typename std::conditional<false,decltype(declval<T&>()++),T>::type>:true_type{};
      
      template<typename T> struct has_predec:false_type{};
      template<typename T> struct has_predec<typename std::condtional<false,decltype(--declval<T&>()),T>::type>:true_type{};
      
      template<typename T> struct has_postdec:false_type{};
      template<typename T> struct has_postdec<typename std::conditional<false,decltype(declval<T&>()--),T>::type>:true_type{};
      
      template<typename T> struct has_address_of:false_type{};
      template<typename T> struct has_address_of<typename std::conditional<false,decltype(&declval<T>()),T>::type>:true_type{};
      
      template<typename T> struct has_dereference:false_type{};
      template<typename T> struct has_dereference<typename std::conditional<false,decltype(*declval<T>()),T>::type>:true_type{};
      
      template<typename T> struct has_umn:false_type{};
      template<typename T> struct has_umn<typename std::conditional<false,decltype(-declval<T>()),T>::type>:true_type{};
      
      template<typename T> struct has_not:false_type{};
      template<typename T> struct has_not<typename std::conditional<false,decltype(~declval<T>()),T>::type>:true_type{};
      
      template<typename T,typename U=unsigned int> struct has_index:false_type{};
      template<typename T,typename U> struct has_index<typename std::conditional<false,decltype(declval<T>()[declval<U>()]),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_addassign:false_type{};
      template<typename T,typename U> struct has_addassign<typename std::conditional<false,decltype(declval<T&>()+=declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_subassign:false_type{};
      template<typename T,typename U> struct has_subassign<typename std::conditional<false,decltype(declval<T&>()-=declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_mulassign:false_type{};
      template<typename T,typename U> struct has_mulassign<typename std::conditional<false,decltype(declval<T&>()*=declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_divassign:false_type{};
      template<typename T,typename U> struct has_divassign<typename std::conditional<false,decltype(declval<T&>()/=declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_modassign:false_type{};
      template<typename T,typename U> struct has_modassign<typename std::conditional<false,decltype(declval<T&>()%=declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_andassign:false_type{};
      template<typename T,typename U> struct has_andassign<typename std::conditional<false,decltype(declval<T&>()&=declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_orassign:false_type{};
      template<typename T,typename U> struct has_orassign<typename std::conditional<false,decltype(declval<T&>()|=declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_xorassign:false_type{};
      template<typename T,typename U> struct has_xorassign<typename std::conditional<false,decltype(declval<T&>()^=declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_rshiftassign:false_type{};
      template<typename T,typename U> struct has_rshiftassign<typename std::conditional<false,decltype(declval<T&>()>>=declval<U>()),T>::type,U>:true_type{};
      
      template<typename T,typename U=T> struct has_lshiftassign:false_type{};
      template<typename T,typename U> struct has_lshiftassign<typename std::conditional<false,decltype(declval<T&>()<<=declval<U>()),T>::type,U>:true_type{};
      
      template<typename T> struct has_negation:false_type{};
      template<typename T> struct has_negation<typename std::conditional<false,decltype(!declval<T>()),T>::type>:true_type{};
      
      
    };
    template<typename T,typename U> struct is_comparable_with:false_type{};
    template<typename T,typename U> struct is_comparable_with<typename std::enable_if<operators::has_multicompare<T,U>::value,T>::type,U>:true_type{};
    template<typename T,typename U> struct is_comparable_with<typename std::enable_if<
      std::conjunction<operators::has_eq<T,U>,operators::has_ne<T,U>,operators::has_lt<T,U>,operators::has_le<T,U>,
        operators::has_ge<T,U>,operators::has_gt<T,U>>::value,T>::type,U>:true_type{};
        
    template<typename T> using is_comparable = is_comparable_with<T,T>;
    
    template<typename T,typename U> struct is_mutually_comparable:false_type{};
    template<typename T> struct is_mutually_comparable<typename std::enable_if<is_comparable<T>::value,T>::type,T>:true_type{};
    template<typename T,typename U> struct is_mutually_comparable<typename std::enable_if<is_comparable_with<T,U>::value,T>::type,
    typename std::enable_if<is_comparable_with<U,T>::value,U>::type>:true_type{};
    
    namespace members_ptrs{
      template<typename T> struct is_const_member_function:false_type{};
      template<typename A,class B,typename... Args> struct is_const_member_function<A B::*(Args...)const>:true_type{};
      template<typename A,class B,typename... Args> struct is_const_member_function<A B::*(Args...)const volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_const_member_function<A B::*(Args...)& const>:true_type{};
      template<typename A,class B,typename... Args> struct is_const_member_function<A B::*(Args...)&& const>:true_type{};
      template<typename A,class B,typename... Args> struct is_const_member_function<A B::*(Args...)& const volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_const_member_function<A B::*(Args...)&& const volatile>:true_type{};
      
      template<typename T> struct is_volatile_member_function:false_type{};
      template<typename A,class B,typename... Args> struct is_volatile_member_function<A B::*(Args...)volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_volatile_member_function<A B::*(Args...)const volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_volatile_member_function<A B::*(Args...)& volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_volatile_member_function<A B::*(Args...)&& volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_volatile_member_function<A B::*(Args...)& const volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_volatile_member_function<A B::*(Args...)&& const volatile>:true_type{};
      
      template<typename T> struct is_constvolatile_member_function:false_type{};
      template<typename A,class B,typename... Args> struct is_constvolatile_member_function<A B::*(Args...)const volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_constvolatile_member_function<A B::*(Args...)& const volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_constvolatile_member_function<A B::*(Args...)&& const volatile>:true_type{};
      
      template<typename T> using is_cvqualified_member_function = std::disjunction<is_const_member_function<T>,is_volatile_member_function<T>>;
      
      template<typename T> struct is_lvalue_ref_member_function:false_type{};
      template<typename A,class B,typename... Args> struct is_lvalue_ref_member_function<A B::*(Args...)&>:true_type{};
      template<typename A,class B,typename... Args> struct is_lvalue_ref_member_function<A B::*(Args...)& const>:true_type{};
      template<typename A,class B,typename... Args> struct is_lvalue_ref_member_function<A B::*(Args...)& volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_lvalue_ref_member_function<A B::*(Args...)& const volatile>:true_type{};
      
      template<typename T> struct is_rvalue_ref_member_function:false_type{};
      template<typename A,class B,typename... Args> struct is_rvalue_ref_member_function<A B::*(Args...)&&>:true_type{};
      template<typename A,class B,typename... Args> struct is_rvalue_ref_member_function<A B::*(Args...)&& const>:true_type{};
      template<typename A,class B,typename... Args> struct is_rvalue_ref_member_function<A B::*(Args...)&& volatile>:true_type{};
      template<typename A,class B,typename... Args> struct is_rvalue_ref_member_function<A B::*(Args...)&& const volatile>:true_type{};
      
      template<typename T> using is_refqualified_member_Function = std::disjunction<is_lvalue_ref_member_function<T>,is_rvalue_ref_member_function<T>>;
      
      [[stdcpp::no_odr]] template<typename T> void from_member_function_pointer(T);
      
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...) mfp){
        return [mfp](B& b,Args... args)->A{return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)const mfp){
        return [mfp](const B& b,Args... args)->A{return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)volatile mfp){
        return [mfp](volatile B& b,Args... args)->A{return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)const volatile mfp){
        return [mfp](const volatile B& b,Args... args)->A{return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)& mfp){
        return [mfp](B& b,Args... args)->A{return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)& const mfp){
        return [mfp](const B& b,Args... args)->A{return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)& volatile mfp){
        return [mfp](volatile B& b,Args... args)->A{return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)& const volatile mfp){
        return [mfp](const volatile B& b,Args... args)->A{return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)&& mfp){
        return [mfp](B&& b,Args... args)->A}return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)&& const mfp){
        return [mfp](const B&& b,Args... args)->A}return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)&& volatile mfp){
        return [mfp](volatile B&& b,Args... args)->A}return b.*mfp(std::forward<Args>(args)...);};
      }
      template<typename A,class B,typename... Args> decltype(auto) from_member_function_pointer(A B::*(Args...)&& const volatile mfp){
        return [mfp](const volatile B&& b,Args... args)->A}return b.*mfp(std::forward<Args>(args)...);};
      }
    };
    
  };

};
