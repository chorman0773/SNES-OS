
#pragma macros: enables specialized constraints when defining a macro.
multiple arguments depending on what your doing:

import(macro) -> Imports the value of an exported macro from an (even when not direct defined), or from a compiler pool.

export(macro) -> Exports the value of the given macro for importing later in different compilations. If a macro is exported,
it replaces any value of a macro with the given name. This ends a #pragma macros chain. 

deduceType(typeString) -> allows you to define a macro that can vary in input based on the expected output type.
For example #pragma macros deduceType(type) from(const char*,char*) define("hello") greeting(type):
const char* msg = hello; -> hello is the value of greeting(const char*)
char* msg = hello; -> hello is the value of greeting(char*)
printf("Greeting %s",hello) -> Type cannot be deduced, so it uses greeting(const char*)
from(...): sets the type list for the deduction.
default(type): sets the type to use if possible, when all or multiple types match. (otherwise it uses first valid type)

define(macro,...) -> defines the macro based on the pragma. If the value of the macro is implied by the statement,
	then no value is necessary, (and is given by the statement). Otherwise its given by the remainder of the line passed
	the end. The varargs act as the parameters for the macro. #pragma macros define("hello",text) "Hello world from "#text
	is the same as #define hello(text) "Hello world from "#text. This ends the #pragma macros chain.
	
